import { IReadWriteClient } from "./IReadWriteClient";
import { IReferenceable, IParameterized, Parameters, IReferences, Descriptor, FilterParams, PagingParams, DataPage } from "pip-services3-commons-node";
import { CompositeLogger, CompositeCounters, Timing } from "pip-services3-components-node";
import { ITempBlobsClientV1 } from "pip-clients-tempblobs-node";
import { RandomDataGenerator } from "../data/RandomDataGenerator";
import { IBatchAllClient } from "./IBatchAllClient";
import { IBatchChangesClient } from "./IBatchChangesClient";
import { IEntityBatchClient } from "./IEntityBatchClient";
import { IBatchEventsClient } from "./IBatchEventsClient";
import { ICapableClient } from "./ICapableClient";
import { CapabilitiesMap } from "../data/CapabilitiesMap";
import { EntityBatch } from "../data/EntityBatch";
export declare class AdapterMemoryClient<T, K> implements ICapableClient, IReadWriteClient<T, K>, IBatchAllClient<T>, IBatchChangesClient<T>, IEntityBatchClient<T>, IBatchEventsClient<T>, IReferenceable, IParameterized {
    protected static readonly _defaultParameters: Parameters;
    protected _references: IReferences;
    protected _logger: CompositeLogger;
    protected _counters: CompositeCounters;
    protected _tempBlob: ITempBlobsClientV1;
    private _parameters;
    constructor(adapter: string, service: string, entities: T[], generator: RandomDataGenerator<T>, references?: IReferences, parameters?: Parameters);
    Adapter: string;
    Service: string;
    Entities: T[];
    Generator: RandomDataGenerator<T>;
    Capabilities: CapabilitiesMap;
    ChangeNotifyQueue: string;
    ChangeNotifyMessageType: string;
    InitialNumberOfEntities: number;
    InitialCreateTime: Date;
    Disabled: boolean;
    CorrelationId: string;
    PageSize: number;
    EntitiesPerBlob: number;
    BlobTimeToLive: number;
    SimulationInterval: number;
    NumberOfChanges: number;
    ErrorProbability: number;
    DistortionsEnabled: boolean;
    RandomErrorsEnabled: boolean;
    ResponseTimeout: number;
    ResponseTimeoutEnabled: boolean;
    NoResponseEnabled: boolean;
    DownloadAllMessageType: string;
    UploadAllMessageType: string;
    DownloadChangesMessageType: string;
    UploadChangesMessageType: string;
    getDescriptor(): Descriptor;
    setReferences(references: IReferences): void;
    setParameters(parameters: Parameters): void;
    protected generateEntities(): T[];
    private _cancelSimulation;
    private delaySimulation;
    beginSimulation(): void;
    close(correlationId: string, callback: (err: any) => void): void;
    protected instrument(correlationId: string, methodName: string, message?: string): Timing;
    protected handleError(correlationId: string, methodName: string, error: Error): Error;
    private raiseRandomException;
    protected beginExecute(action: () => void): void;
    getCapabilities(): CapabilitiesMap;
    getByFilter(correlationId: string, filter: FilterParams, paging: PagingParams, callback: (err: any, page: DataPage<T>) => void): void;
    getOneById(correlationId: string, id: K, callback: (err: any, entity: T) => void): void;
    create(correlationId: string, entity: T, callback: (err: any, entity: T) => void): void;
    update(correlationId: string, entity: T, callback: (err: any, entity: T) => void): void;
    deleteById(correlationId: string, id: K, callback: (err: any, entity: T) => void): void;
    private skipAndTake;
    private toStringArray;
    protected performChangeNotify(correlationId: string, entity: T, changeType: string): void;
    protected performGet(correlationId: string, filter: FilterParams, filterFunc?: (item: T) => boolean): T[];
    protected performGetById(correlationId: string, id: string): T;
    protected performCreate(correlationId: string, entity: T): T;
    protected performFind(correlationId: string, entity: T): T;
    protected performUpdate(correlationId: string, entity: T): T;
    protected performDelete(correlationId: string, id: string): T;
    downloadAll(correlationId: string, responseQueueName: string, requestId: string, callback: (err: any) => void): void;
    uploadAll(correlationId: string, blobIds: string[], responseQueueName: string, requestId: string, callback: (err: any) => void): void;
    private sendConfirm;
    downloadChanges(correlationId: string, filter: FilterParams, fromTime: Date, toTime: Date, responseQueueName: string, requestId: string, callback: (err: any) => void): void;
    uploadChanges(correlationId: string, blobIds: string[], responseQueueName: string, requestId: string, callback: (err: any) => void): void;
    getBatches(correlationId: string, filter: FilterParams, paging: PagingParams, callback: (err: any, page: DataPage<EntityBatch<T>>) => void): void;
    ackBatchById(correlationId: string, batchId: string, callback: (err: any) => void): void;
    downloadEvents(correlationId: string, filter: FilterParams, fromTime: Date, toTime: Date, responseQueueName: string, requestId?: string, callback?: (err: any) => void): void;
    uploadEvents(correlationId: string, blobIds: string[], responseQueueName: string, requestId?: string, callback?: (err: any) => void): void;
    private isChangeable;
    private isIdentifiable;
    private isNamed;
}
